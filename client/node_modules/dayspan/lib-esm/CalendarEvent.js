"use strict";
import { Constants } from './Constants';
/**
 * An instance of an [[Event]] on a given day of a [[Calendar]] generated by
 * the event's [[Schedule]].
 *
 * @typeparam T The type of data stored in the [[Event]] class.
 * @typeparam M The type of metadata stored in the schedule and in this class.
 */
export class CalendarEvent {
    /**
     * Creates a new event instance given the id, the event paired with the
     * schedule, the schedule, the time span of the event, and the day on the
     * calendar the event belongs to.
     *
     * @param id The relatively unique identifier of this event.
     * @param event The event which created this instance.
     * @param time The time span of this event.
     * @param actualDay The day on the calendar this event is for.
     */
    constructor(id, event, time, actualDay) {
        /**
         * The row this event is on in a visual calendar. An event can span multiple
         * days and it is desirable to have the occurrence on each day to line up.
         * This is only set when [[Calendar.updateRows]] is true or manually set.
         * This value makes sense for visual calendars for all day events or when the
         * visual calendar is not positioning events based on their time span.
         */
        this.row = 0;
        /**
         * The column this event is on in a visual calendar. An event can have its
         * time overlap with another event displaying one of the events in another
         * column. This is only set when [[Calendar.updateColumns]] is true or
         * manually set. This value makes sense for visual calendars that are
         * displaying event occurrences at specific times positioned accordingly.
         */
        this.col = 0;
        this.id = id;
        this.event = event;
        this.time = time;
        this.day = actualDay;
        this.fullDay = event.schedule.isFullDay();
        this.meta = event.schedule.getMeta(time.start);
        this.cancelled = event.schedule.isCancelled(time.start);
        this.starting = time.isPoint || time.start.sameDay(actualDay);
        this.ending = time.isPoint || time.end.relative(-1).sameDay(actualDay);
    }
    /**
     * The id of the schedule uniqe within the calendar which generated this event.
     */
    get scheduleId() {
        return Math.floor(this.id / Constants.MAX_EVENTS_PER_DAY);
    }
    /**
     * The start timestamp of the event.
     */
    get start() {
        return this.time.start;
    }
    /**
     * The end timestamp of the event.
     */
    get end() {
        return this.time.end;
    }
    /**
     * The schedule which generated this event.
     */
    get schedule() {
        return this.event.schedule;
    }
    /**
     * The related event data.
     */
    get data() {
        return this.event.data;
    }
    /**
     * An [[IdentifierInput]] for the start of this event.
     */
    get identifier() {
        return this.identifierType.get(this.start);
    }
    /**
     * The [[Identifier]] for this event. Either [[Identifier.Day]] or
     * [[Identifier.Time]].
     */
    get identifierType() {
        return this.schedule.identifierType;
    }
    /**
     * Returns a delta value between 0 and 1 which represents where the
     * [[CalendarEvent.start]] is relative to [[CalendarEvent.day]]. The delta
     * value would be less than 0 if the start of the event is before
     * [[CalendarEvent.day]].
     */
    get startDelta() {
        return this.time.startDelta(this.day);
    }
    /**
     * Returns a delta value between 0 and 1 which represents where the
     * [[CalendarEvent.end]] is relative to [[CalendarEvent.day]]. The delta value
     * would be greater than 1 if the end of the event is after
     * [[CalendarEvent.day]].
     */
    get endDelta() {
        return this.time.endDelta(this.day);
    }
    /**
     * Calculates the bounds for this event if it were placed in a rectangle which
     * represents a day (24 hour period). By default the returned values are
     * between 0 and 1 and can be scaled by the proper rectangle dimensions or the
     * rectangle dimensions can be passed to this function.
     *
     * @param dayHeight The height of the rectangle of the day.
     * @param dayWidth The width of the rectangle of the day.
     * @param columnOffset The offset in the rectangle of the day to adjust this
     *    event by if it intersects or is contained in a previous event. This also
     *    reduces the width of the returned bounds to keep the bounds in the
     *    rectangle of the day.
     * @param clip `true` if the bounds should stay in the day rectangle, `false`
     *    and the bounds may go outside the rectangle of the day for multi-day
     *    events.
     * @param offsetX How much to translate the left & right properties by.
     * @param offsetY How much to translate the top & bottom properties by.
     * @returns The calculated bounds for this event.
     */
    getTimeBounds(dayHeight = 1, dayWidth = 1, columnOffset = 0.1, clip = true, offsetX = 0, offsetY = 0) {
        return this.time.getBounds(this.day, dayHeight, dayWidth, this.col * columnOffset, clip, offsetX, offsetY);
    }
    /**
     * Changes the cancellation status of this event. By default this cancels
     * this event - but `false` may be passed to undo a cancellation.
     *
     * @param cancelled Whether the event should be cancelled.
     */
    cancel(cancelled = true) {
        this.schedule.setCancelled(this.start, cancelled);
        this.cancelled = cancelled;
        return this;
    }
    /**
     * Changes the exclusion status of this event. By default this excludes this
     * event - but `false`  may be passed to undo an exclusion.
     *
     * @param excluded Whether the event should be excluded.
     */
    exclude(excluded = true) {
        this.schedule.setExcluded(this.start, excluded);
        return this;
    }
    /**
     * Moves this event to potentially another day and time. A move is
     * accomplished by excluding the current event and adding an inclusion of the
     * new day & time. Any [[CalendarEvent.meta]] on this event will be moved to
     * the new event. If the schedule represents a single event
     * ([[Schedule.isSingleEvent]]) then the schedule frequencies are updated
     * to match the timestamp provided.
     *
     * @param toTime The timestamp to move this event to.
     * @returns Whether the event was moved to the given time.
     */
    move(toTime) {
        return this.schedule.move(toTime, this.start);
    }
}
//# sourceMappingURL=CalendarEvent.js.map